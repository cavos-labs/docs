---
title: "Message Signing"
description: "Sign messages with your wallet"
---

## Overview

Sign messages for authentication, proof of ownership, or off-chain signatures.

<Warning>
Message signing for arbitrary strings is **not yet fully implemented** in the OAuth wallet flow. TypedData signing for transactions works transparently—this limitation only affects standalone message signing for authentication purposes.
</Warning>

## Current Status

| Feature | Status |
|---------|--------|
| Transaction signing | ✅ Fully supported |
| Session key signing | ✅ Automatic |
| TypedData (in transactions) | ✅ Supported |
| Standalone `signMessage()` | ⏳ Coming soon |

## How Transaction Signing Works

When you execute transactions, the SDK automatically signs them using your session key:

```tsx
import { useCavos } from '@cavos/react';

function TransferButton() {
  const { execute, address } = useCavos();

  const handleTransfer = async () => {
    // Transactions are automatically signed with your session key
    const txHash = await execute({
      contractAddress: '0x...',
      entrypoint: 'transfer',
      calldata: [recipient, amount],
    });
  };

  return <button onClick={handleTransfer}>Transfer</button>;
}
```

## Workaround: Typed Data in Transactions

For off-chain signatures (like order signing for DEXs), you can use a contract that accepts typed data:

```tsx
// Sign an order by executing a contract call
const txHash = await execute({
  contractAddress: '0x_YOUR_ORDER_CONTRACT',
  entrypoint: 'submit_signed_order',
  calldata: [
    orderId,
    tokenIn,
    amountIn,
    tokenOut,
    minAmountOut,
    expiry,
  ],
});
```

The contract can then verify the caller is the expected wallet.

## Future: Standalone Message Signing

When `signMessage()` is fully implemented, it will support:

### Simple String

```tsx
// Coming soon
const signature = await signMessage('Hello World');
```

### TypedData (EIP-712 style)

```tsx
// Coming soon
const typedData = {
  types: {
    StarkNetDomain: [
      { name: 'name', type: 'shortstring' },
      { name: 'version', type: 'shortstring' },
    ],
    Message: [
      { name: 'content', type: 'felt' },
    ],
  },
  primaryType: 'Message',
  domain: {
    name: 'MyApp',
    version: '1',
  },
  message: {
    content: '0x1234...',
  },
};

const signature = await signMessage(typedData);
```

## Signature Format

When implemented, signatures will use the STARK curve ECDSA format:

```typescript
interface Signature {
  r: string;
  s: string;
}
```

## Use Cases (Future)

### Authentication
```tsx
const message = `Sign in to MyApp: ${nonce}`;
const signature = await signMessage(message);
// Send to server for verification
```

### Proof of Ownership
```tsx
const message = `I own wallet ${address} on ${new Date().toISOString()}`;
const signature = await signMessage(message);
```

<Note>
For authentication use cases **today**, consider using the user's OAuth identity (email/sub) directly since Cavos guarantees the wallet derives from a verified OAuth identity.
</Note>
