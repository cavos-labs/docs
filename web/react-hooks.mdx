---
title: "React Hooks"
description: "useCavos and useSession hook reference"
---

## CavosProvider

The provider component that initializes the SDK and provides context to child components.

```tsx
import { CavosProvider } from '@cavos/react';

<CavosProvider config={config}>
  <App />
</CavosProvider>
```

### Config Props

```typescript
interface CavosConfig {
  appId: string;                    // Required: Your Cavos App ID
  network?: 'sepolia' | 'mainnet';  // Default: 'sepolia'
  paymasterApiKey?: string;         // Custom paymaster key
  starknetRpcUrl?: string;          // Custom RPC URL
  enableLogging?: boolean;          // Enable debug logs
  passkeyModal?: {                  // Modal customization
    title?: string;
    description?: string;
    buttonText?: string;
  };
}
```

## useCavos Hook

Access SDK functionality from any child component:

```tsx
import { useCavos } from '@cavos/react';

function MyComponent() {
  const {
    // State
    isAuthenticated,
    user,
    address,
    isLoading,
    hasActiveSession,
    requiresWalletCreation,
    
    // Actions
    login,
    createWallet,
    execute,
    signMessage,
    logout,
    deleteAccount,
    retryWalletUnlock,
    getOnramp,
    
    // SDK instance
    cavos,
  } = useCavos();

  return <div>...</div>;
}
```

### State Properties

| Property | Type | Description |
|----------|------|-------------|
| `isAuthenticated` | boolean | User is authenticated (OAuth or passkey) |
| `user` | UserInfo \| null | User info from OAuth (or placeholder for passkey) |
| `address` | string \| null | Wallet address if loaded |
| `isLoading` | boolean | SDK is initializing or processing |
| `hasActiveSession` | boolean | Session is active and not expired |
| `requiresWalletCreation` | boolean | User needs to create wallet (shows modal) |

### Action Methods

#### login(provider, credentials?, redirectUri?)

Start authentication flow:

**Social Login (Google/Apple):**
```tsx
await login('google');
await login('apple');
await login('google', undefined, 'https://myapp.com/callback');
```

**Email/Password (Firebase):**
```tsx
await login('firebase', {
  email: 'user@example.com',
  password: 'password123'
});
```

**Error Handling:**
```tsx
try {
  await login('firebase', { email, password });
} catch (error) {
  if (error.name === 'EmailNotVerifiedError') {
    // Email not verified yet
    console.log('Unverified email:', error.email);
  } else if (error.message?.includes('auth/wrong-password')) {
    // Invalid credentials
  }
}
```

#### register(provider, credentials)

Register a new user with email/password:

```tsx
try {
  await register('firebase', {
    email: 'user@example.com',
    password: 'secure123'
  });
  // Verification email sent
  alert('Check your email to verify your account!');
} catch (error) {
  if (error.name === 'EmailVerificationRequiredError') {
    // Registration successful, email sent
  } else if (error.error === 'rate_limited') {
    // Too many requests
    console.log('Wait seconds:', error.wait_seconds);
  }
}
```

#### createWallet()

Create or recover a wallet:

```tsx
await createWallet();
```

For passkey-only mode, call this without prior `login()`.

#### execute(calls)

Execute transactions using session keys:

```tsx
// Requires active session!
const txHash = await execute({
  contractAddress: '0x...',
  entrypoint: 'transfer',
  calldata: ['0x...', '1000', '0'],
});
```

> [!NOTE]
> All transactions are signed with the session key and are gasless. No signature prompt appears.

#### signMessage(messageHash)

Sign a message with the session key:

```tsx
const signature = await signMessage('0x123...'); // hex string message hash
// Returns { r: string, s: string }
```

#### logout()

Clear session and wallet:

```tsx
await logout();
```

#### deleteAccount()

Permanently delete account:

```tsx
await deleteAccount();
```

#### Additional Methods

The `cavos` instance provides additional utility methods:

```tsx
const { cavos } = useCavos();

// Check email verification status
const isVerified = await cavos.isEmailVerified('user@example.com');

// Resend verification email
await cavos.resendVerificationEmail('user@example.com');

// Get wallet balance
const balance = await cavos.getBalance();

// Check if account is deployed
const deployed = await cavos.isAccountDeployed();
```

## useSession Hook

Manage session keys for signature-free transactions:

```tsx
import { useSession } from '@cavos/react';

function SessionManager() {
  const {
    hasActiveSession,
    createSession,
    clearSession,
    executeWithSession,
  } = useSession();

  return <div>Session: {hasActiveSession ? 'Active' : 'Inactive'}</div>;
}
```

### Session Properties

| Property | Type | Description |
|----------|------|-------------|
| `hasActiveSession` | boolean | Session is active and not expired |

### Session Methods

#### createSession(policy)

Create a session with a policy defining allowed actions:

```tsx
await createSession({
  allowedMethods: [
    { contractAddress: '0x...token', selector: 'transfer' },
    { contractAddress: '0x...token', selector: 'approve' },
    { contractAddress: '0x...nft', selector: 'mint' },
  ],
  expiresAt: Date.now() + 60 * 60 * 1000, // 1 hour
});
```

> [!IMPORTANT]
> After `createSession()`, the user's private key is **cleared from memory**. Only the session key remains.

#### clearSession()

Invalidate the current session:

```tsx
clearSession();
```

#### executeWithSession(calls)

Execute transactions with the session key:

```tsx
const txHash = await executeWithSession({
  contractAddress: '0x...',
  entrypoint: 'transfer',
  calldata: ['0x...', '1000', '0'],
});
```

## Complete Example

```tsx
import { useCavos, useSession } from '@cavos/react';

function App() {
  const { login, logout, address, isAuthenticated } = useCavos();
  const { hasActiveSession, createSession } = useSession();

  const handleSetup = async () => {
    // 1. Authenticate
    await login('google');
    
    // 2. Create session (user signs once)
    await createSession({
      allowedMethods: [
        { contractAddress: TOKEN_ADDRESS, selector: 'transfer' },
      ],
      expiresAt: Date.now() + 60 * 60 * 1000,
    });
    
    // ✓ Ready for signature-free transactions
  };

  const handleTransfer = async () => {
    const { execute } = useCavos();
    
    // No signature popup!
    const txHash = await execute({
      contractAddress: TOKEN_ADDRESS,
      entrypoint: 'transfer',
      calldata: [recipient, amount, '0'],
    });
  };

  if (!isAuthenticated) {
    return <button onClick={handleSetup}>Login</button>;
  }

  return (
    <div>
      <p>Address: {address}</p>
      <p>Session: {hasActiveSession ? '✅ Active' : '❌ Create session first'}</p>
      <button onClick={handleTransfer} disabled={!hasActiveSession}>
        Transfer
      </button>
      <button onClick={logout}>Logout</button>
    </div>
  );
}
```

## Session Policy Reference

```typescript
interface SessionPolicy {
  allowedMethods: Array<{
    contractAddress: string;  // Contract address (hex)
    selector: string;         // Function name
  }>;
  expiresAt: number;          // Timestamp in milliseconds
  metadata?: string;          // Optional metadata
}
```

### Best Practices

1. **Limit scope**: Only include methods your app actually needs
2. **Short expiration**: Use 1 hour or less for sensitive operations
3. **Re-create on demand**: Create new sessions when needed rather than long-lived ones
4. **Check before execute**: Always verify `hasActiveSession` before `execute()`
